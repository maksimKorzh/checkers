<html lang="en" style="touch-action: none;">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <base href="bangladesh-checkers">
    <style>
      html, body { margin: 0; padding: 0; width: 100%; height: 100dvh; background-color: white; }
      body { padding: 0px; margin: 0px; font-family: monospace; font-size: 20px; background-color: white; }
      button { width: 100%; height: 80px; font-size: inherit; font-family: inherit; background-color: white; color: black; }
      .highlight { box-shadow: inset 0px 0px 10px 10px #ff0; }
    </style>
  </head>
  <body>
    <div id="game-container" style="display: flex; flex-direction: column; align-items: center; width: 100%; height: 100%;">
      <div id="board"></div>
      <div id="buttons" style="display: flex; justify-content: center; gap: 1px; margin-top: 10px;">
        <button onclick="window.location.reload();">Play</button>
        <button onclick="ai ^= 1; alert('AI is now ' + (ai ? 'on' : 'off'));">AI</button>
        <button id="undo">Undo</button>
        <button id="move">Move</button>
        <button id="flip">Flip</button>
      </div>
    </div>
    <script>
      let width = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth;
      let size = parseInt(width / (window.innerWidth > window.innerHeight ? 10 : 8.2 ));
      let radius = size / 3;

      let whiteMan = `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="white circle">
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius}" 
            fill="#f6f9f5" 
            stroke="black" 
            stroke-width="2"
          />
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius-(radius/2)}" 
            fill="none" 
            stroke="black" 
            stroke-width="2"
          />
        </svg>`;

      let redMan = `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius}" 
            fill="#e52818" 
            stroke="black" 
            stroke-width="2"
          />
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius-(radius/2)}" 
            fill="none" 
            stroke="black" 
            stroke-width="2"
          />
        </svg>`;

      let redKing = `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius}" 
            fill="#e52818" 
            stroke="#222" 
            stroke-width="6"
          />
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius-(radius/2)}" 
            fill="none" 
            stroke="#222" 
            stroke-width="6"
          />
        </svg>`;

      let whiteKing = `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius}" 
            fill="#f6f9f5" 
            stroke="#222" 
            stroke-width="6"
          />
          <circle 
            cx="${size / 2}" 
            cy="${size / 2}" 
            r="${radius-(radius/2)}" 
            fill="none" 
            stroke="#222" 
            stroke-width="6"
          />
        </svg>`;

      var board = [
        0, 2, 0, 2, 0, 2, 0, 2,   0, 0, 0, 0, 0, 0, 0, 0,
        2, 0, 2, 0, 2, 0, 2, 0,   0, 0, 0, 0, 0, 0, 0, 0,
        0, 2, 0, 2, 0, 2, 0, 2,   0, 5, 0, 5, 0, 5, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 9, 0, 9, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 9, 0, 9, 0, 0,
        1, 0, 1, 0, 1, 0, 1, 0,   0, 0, 5, 0, 5, 0, 5, 0,
        0, 1, 0, 1, 0, 1, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 1, 0, 1, 0, 1, 0,   0, 0, 0, 0, 0, 0, 0, 0,
      ];
      
      var directions = [
          [],
          [-15, -17],
          [15, 17],
          [], [],
          [-15, -17, 15, 17],
          [-15, -17, 15, 17],
      ];

      var pieceScores = [0, 200, -200, 0, 0, 400, -400];
      
      var side = 1;
      var clickLock = 0;
      var flip = 0;
      var userSrc, userDst;
      var legalMoves = [];
      var gameMoves = [];
      var currentSequence = {};
      var gameOver = 0;
      var ai = 1;
      var capPly = 0;
      
      function printBoard() {
        let boardStr = '';
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 16; col++) {
            let sq = row * 16 + col;
            if (sq & 0x88) continue;
            boardStr += ' ' + ['.', 'x', 'o', '', '', 'X', 'O'][board[sq]];
          } boardStr += '\n';
        } console.log(boardStr);
      }
      
      function drawBoard() {
        let boardHTML = `<table align="center" cellspacing="0" `;
        boardHTML += `style=" -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none;`;
        boardHTML += `user-select: none; -o-user-select: none;`;
        boardHTML += `unselectable="on" onselectstart="return false;" onmousedown="return false;"`;
        for (let row = 0; row < 8; row++) {
          boardHTML+= '<tr>';
          for (let col = 0; col < 16; col++) {
            let file, rank;
            if (flip) {
              file = 16-1-col;
              rank = 8-1-row;
            } else {
              file = col;
              rank = row;
            }
            let sq = rank * 16 + file;
            if (sq & 0x88) continue;
            boardHTML+= '<td align="center" id="' + sq +
                 '"bgcolor="#' + ( ((col + row) % 2) ? '59aa67' : 'eef2e1') +
                 '" style="width: ' + size + 'px; height: ' + size + 'px; padding: 0px; font-size: ' + (size/2) + 'px; border: 1px solid black;"' +
                 ' onclick="userMove(this.id)">' + ['<span style=\'visibility:hidden\'>' + redMan + '</span>', redMan, whiteMan, '', '', redKing, whiteKing][board[sq]] +
                 '</td>';
          } boardHTML+= '</tr>';
        } boardHTML+= '</table>';
        document.getElementById('board').innerHTML = boardHTML;
        document.getElementById('buttons').style.width = (document.getElementById('board').offsetWidth) + 'px';
        setTimeout(function() { isGameOver(); }, 200);
      } drawBoard();

      function generateCaptureSequences(sq) {
        let captures = findCaptures(sq, board[sq]);
        if (captures.length == 0) return [[]];
        let sequences = [];
        for (let cap of captures) {
          makeMove(cap); capPly++;
          let subCaps = generateCaptureSequences(cap[1]);
          for (let subCap of subCaps) sequences.push([cap, ...subCap]);
          undoMove(cap); capPly--;
        } return sequences;      
      }

      function findCaptures(sq, pce) {
        if ([1, 3, 5, 7, 112, 114, 116, 118].includes(sq) && pce > 2 && capPly) return [];
        let captures = [];
        for (let dir of directions[board[sq]]) {
          if ((board[sq + dir]&3) != (3-(board[sq]&3))) continue;
          if ((sq + dir*2) & 0x88) continue;
          if (board[sq + dir*2] == 0 && board[sq + dir])
            captures.push([sq, (sq+dir*2), (sq+dir), board[sq], board[sq+dir]]);
        } return captures;
      }

      function moveToString(move) {
        function indexToCoords(i) {
          let r = 7-Math.floor(i/16)+1;
          let c = i % 16;
          return 'abcdefgh'[c]+r;
        }
        let srcSq = indexToCoords(move[0]);
        let dstSq = indexToCoords(move[1]);
        return srcSq + dstSq;
      }

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
      
      async function animateSequence(sequence) {
        for (let move of sequence) {
          await sleep(500);
          makeMove(move);
          drawBoard();
        } side = 3 - side;
        document.getElementById(sequence[0][1]).classList.add('highlight');
      }

      function makeSequence(sequence) {
        for (let move of sequence) makeMove(move);
        side = 3 - side;
      }
      
      function undoSequence(sequence) {
        for (let i = sequence.length-1; i >= 0; i--) undoMove(sequence[i]);
        side = 3 - side;
      }
      
      function makeMove(move) {
        board[move[2]] = 0;
        board[move[1]] = move[3];
        board[move[0]] = 0;
        if ([1, 3, 5, 7, 112, 114, 116, 118].includes(move[1])) board[move[1]] |= 4;
      }
      
      function undoMove(move) {
        board[move[0]] = move[3];
        board[move[1]] = 0;
        board[move[2]] = move[4];
      }

      function generateCaptures() {
        let moves = [];
        for (let sq = 0; sq < board.length; sq++) {
          if (sq & 0x88) continue;
          if (!(board[sq] & side)) continue;
          moves.push(generateCaptureSequences(sq));
        } return moves;
      }

      function generateQuiets() {
        let moves = [];
        let srcSq, dstSq, capSq, pce, capPce;
        for (let sq = 0; sq < board.length; sq++) {
          if (sq & 0x88) continue;
          srcSq = sq;
          pce = board[srcSq];
          if (!(pce & side)) continue;
          for (let dir of directions[pce]) {
            dstSq = srcSq + dir;
            capSq = dstSq;
            capPce = board[capSq];
            if (board[capSq] || capSq & 0x88) continue;
            moves.push([srcSq, dstSq, capSq, pce, capPce]);
          }
        } return [[moves]];
      }
      
      function generateMoves() {
        let moves = generateCaptures();
        for (let move of moves) {
          for (let sequence of moves) {
            if (sequence[0].length) return moves;
          }
        } return generateQuiets();
      }
      
      function evaluate() {
        let score = 0;
        for (let sq = 0; sq < board.length; sq++) {
          if (sq & 0x88 || !board[sq]) continue;
          score += pieceScores[board[sq]];
          if ((board[sq]&3) == 1) score += board[sq+8];
          if ((board[sq]&3) == 2) score -= board[sq+8];
        } return (side == 1) ? score : -score
      }
      
      function search(depth) {
        let bestMove = null;
        const originalDepth = depth;
        console.log('Searching root moves:');
        
        function quiescence() {
          let standPat = evaluate();
          const captures = generateCaptures();
          if (!captures.length) return standPat;
          let bestScore = standPat;
          for (let move of captures) {
            for (let sequence of move) {
              if (!sequence.length) continue;
              makeSequence(sequence);
              let score = -quiescence();
              undoSequence(sequence);
              if (score > bestScore) bestScore = score;
            }
          } return bestScore;
        }
        
        function negamax(depth) {
          if (depth === 0) return quiescence();
          let bestScore = -Infinity;
          var moves = generateMoves();
          if (moves.length == 1 && moves[0].length == 1 && moves[0][0].length == 0) return -99999 + depth;
          if (moves[0][0].length > 1 &&  !moves[0][0][0][4] && moves[0][0][0][1] != moves[0][0][1][0]) {
            let quiets = [];
            for (let move of moves[0][0]) quiets.push([[move]]);
            moves = quiets;
          }
          for (let move of moves) {
            for (let sequence of move) {
              if (!sequence.length) continue;
              makeSequence(sequence);
              let score = -negamax(depth - 1);
              if (depth == originalDepth) console.log(moveToString(sequence[0]) + ":", score);
              undoSequence(sequence);
              if (score > bestScore) {
                bestScore = score;
                if (depth === originalDepth) bestMove = sequence;
              }
            }
          } return bestScore;
        }
        
        const bestScore = negamax(depth);
        return { bestScore, bestMove };
      }

      function userMove(sq) {
        if (gameOver) return;
        var clickSq = parseInt(sq, 10);
        if (!clickLock && board[clickSq]) {
          for (let sq = 0; sq < board.length; sq++)
            document.getElementById(clickSq).classList.remove('highlight');
          document.getElementById(clickSq).classList.add('highlight');
          legalMoves = generateMoves();
          for (let move of legalMoves) {
            for (let sequence of move) {
              for (let submove of sequence) {
                if (clickSq == submove[0]) {
                  document.getElementById(submove[1]).classList.add('highlight');
                  userSrc = clickSq;
                }
              }
            }
          } clickLock = 1;
        } else if (clickLock) {
          userDst = clickSq;
          drawBoard();
          for (let move of legalMoves) {
            for (let sequence of move) {
              for (let submove of sequence) {
                if (userSrc == submove[0] && userDst == submove[1]) {
                  makeMove(submove);
                  currentSequence[submove.toString()] = submove;
                  if (!submove[4]) {
                    side = 3 - side;
                    gameMoves.push([submove]);
                    currentSequence = {};
                    computerMove();
                  } else if (sequence.length == 1) {
                    side = 3 - side;
                    let lastMove = [];
                    for (let entry of Object.entries(currentSequence)) lastMove.push(entry[1]);
                    gameMoves.push(lastMove);
                    currentSequence = {};
                    computerMove();
                  } drawBoard();
                  clickLock = 0;
                  document.getElementById(userDst).classList.add('highlight');
                  return;
                }
              }
            }
          } clickLock = 0;
        }
      }

      function computerMove() {
        if (!ai) return;
        setTimeout(function() {
          let computerMove = search(7);
          if (computerMove.bestMove && computerMove.bestMove.length) {
            gameMoves.push(computerMove.bestMove);
            animateSequence(computerMove.bestMove);
          } else return;
        }, 100);
      }
      
      function isGameOver() {
        if (gameOver) return;
        let white = 0;
        let red = 0;
        for (let sq = 0; sq < board.length; sq++) {
          if (board[sq] & 0x88) continue;
          if ((board[sq]&3) == 1) red += 1;
          if ((board[sq]&3) == 2) white += 1;
        }
        if (!white) { gameOver = 1; alert('Red won!'); }
        if (!red) { gameOver = 1; alert('White won!'); }
      }
      
      document.getElementById('undo').addEventListener('click', () => {
        if (!gameMoves.length) return;
        let lastMove = gameMoves[gameMoves.length-1];
        undoSequence(lastMove);
        gameMoves.pop();
        drawBoard();
      });
      
      document.getElementById('move').addEventListener('click', () => {
        computerMove();
      });
      
      document.getElementById('flip').addEventListener('click', () => {
        flip ^= 1;
        drawBoard();
      });
    </script>
  </body>
</html>
